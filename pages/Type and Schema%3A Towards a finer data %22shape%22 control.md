- Different concepts that are ultimately the same get reinvented all the time. The reason why we have different Different concepts, though, is that we are approaching the same problem from different angle. Today, I want to talk about type and schema.
  title:: Type and Schema: Towards a finer data "shape" control
- Type is invented to alleviate the pain in untyped programming.
	- Say I have a 64-bit register storing a random number. Without extra information, only god will know what operation should be legal on that number. What if it's a C-style string? what if it's a function pointer? what if it's actually a 64bit integer? It's clear that allowing everything to happen on that 64bit register is a pain in the ass. And therefore, type is invented.
	- With type information, the possible operation on that specific type is constrained. So, you are not allowed to add a C-style string pointer to a function pointer, and you are not allowed to call the address at a specific integer.
	- But that's not all. For many types in many programming languages, the type information get erased at runtime, so it does not incur runtime overhead. That's cool because we now have zero-cost abstraction. Hooray! However, we soon found out that it's hard to express some valid program, if we have a traditional type system. (e.g. C's type system)
- Schema, on the other hand, is first used in database, to validate the shape of the data is correct. Guess what? That is partially the job that is done by a type system! A type system validate the shape of the data, additionally, it specifies what operations are valid on those data.
	- Schema is not usually part of the compiler, unlike type system. I would also say, Schema is the type-system of runtime.
	- In which situation we need schema? The most common case is for JSON-validation. And why JSON? Because JSON don't have a specific "shape". Let me translate this into the background of a type system: In dynamically-typed language, we don't have the type information of the data until runtime. If we need to doing data validation at runtime, this is in some sense, just "type-checking" but in runtime.
	- And it really is. People have been blaming dynamically-typed language for producing program that is not maintainable and buggy, which is true given a novice programmer for both a statically typed language and a dynamically typed language. To overcome this, schema validation is used extensively in many of the programming language.
- Ok, if schema is so good, why not just use schema all the time, and make a type system that is as flexible as schema? The answer is you technically can, but there's problem about that: this is not zero cost abstraction. validating schema is slow, and maybe even Turing complete, or you must keep track of the information all the time. What if I want to represent a type, that only prime numbers are valid instance of this type, and how should it related to the type natural numbers? What if I want to represent a type, that only DAG are valid instance of this type? How should it related to the type Graph? I don't believe present type system is possible to achieve this. But It's pretty clear that we may use schema, instead of type, and replace the type slot with "schema" and passing this schema around.
- One of the surprising thing is that schema is serializable, that is due to any code is actually serializable (if you don't know Lisp, I strongly recommend you to study it). Thus, it should be possible to keep around a set of schema in place of type information, when type is just not erasable.
- That, would make our hypothetical language as fast as statically-typed language, as long as the program we wrote is still possible to express in a statically-typed language. Also, it will make our language as flexible as a dynamically-typed language. What's more, making schema part of the type system make the language more safe and robust.
- I don't know if it exists before, but I think that would be a really cool feature. I'll name this **schematized-type**.